name: 'OSPS Security Assessment'
description: 'Run Open Source Project Security Baseline assessments on your GitHub repository'
author: 'Revanite'

branding:
  icon: 'shield'
  color: 'blue'

inputs:
  owner:
    description: 'Repository owner (organization or user)'
    required: true
  repo:
    description: 'Repository name'
    required: true
  token:
    description: 'GitHub Personal Access Token with repo read permissions'
    required: true
  catalog:
    description: 'OSPS catalog to assess against'
    required: false
    default: 'osps-baseline'
  maturity-level:
    description: 'Maturity level to assess'
    required: false
    default: 'Maturity Level 1'
  log-level:
    description: 'Log level (info, debug, trace)'
    required: false
    default: 'info'
  output-format:
    description: 'Output format (yaml, json, or sarif)'
    required: false
    default: 'yaml'
  upload-sarif:
    description: 'Upload results as SARIF to GitHub Security tab. When true, output-format is automatically set to sarif'
    required: false
    default: 'false'

outputs:
  results-path:
    description: 'Path to the evaluation results directory'
    value: 'evaluation_results'

runs:
  using: 'composite'
  steps:
    - name: Create config file
      shell: bash
      env:
        LOG_LEVEL: ${{ inputs.log-level }}
        OUTPUT_FORMAT: ${{ inputs.output-format }}
        CATALOG: ${{ inputs.catalog }}
        MATURITY_LEVEL: ${{ inputs.maturity-level }}
        OWNER: ${{ inputs.owner }}
        REPO: ${{ inputs.repo }}
        TOKEN: ${{ inputs.token }}
        UPLOAD_SARIF: ${{ inputs.upload-sarif }}
      run: |
        # If upload-sarif is enabled, use sarif output format
        if [ "$UPLOAD_SARIF" = "true" ]; then
          FINAL_OUTPUT_FORMAT="sarif"
        else
          FINAL_OUTPUT_FORMAT="$OUTPUT_FORMAT"
        fi

        cat > /tmp/pvtr-config.yml << EOF
        loglevel: "$LOG_LEVEL"
        write-directory: evaluation_results
        write: true
        output: "$FINAL_OUTPUT_FORMAT"
        services:
          pvtr:
            plugin: github-repo
            policy:
              catalogs:
                - "$CATALOG"
              applicability:
                - "$MATURITY_LEVEL"
            vars:
              owner: "$OWNER"
              repo: "$REPO"
              token: "$TOKEN"
        EOF

    - name: Prepare writable results directory
      shell: bash
      run: |
        mkdir -p evaluation_results
        chmod 777 evaluation_results

    - name: Run OSPS Assessment
      shell: bash
      run: |
        docker run --rm \
          -v /tmp/pvtr-config.yml:/.privateer/config.yml \
          -v ${{ github.workspace }}/evaluation_results:/.privateer/bin/evaluation_results \
          eddieknight/pvtr-github-repo:latest

    - name: Enrich SARIF with all assessment results
      shell: bash
      if: inputs.upload-sarif == 'true'
      continue-on-error: true
      run: |
        SARIF_FILE=$(find evaluation_results -name "*.sarif" -type f 2>/dev/null | head -1)
        YAML_FILE=$(find evaluation_results -name "*.yaml" -type f 2>/dev/null | head -1)

        if [ -z "$SARIF_FILE" ] || [ ! -f "$SARIF_FILE" ]; then
          echo "⚠️  No SARIF file found"
          exit 0
        fi

        # Create a Python script to enrich SARIF with results from YAML
        cat > /tmp/enrich_sarif.py << 'PYTHON_SCRIPT'
        import json
        import yaml
        import sys
        import os

        def map_result_to_sarif_level(result):
            """Map assessment result to SARIF level"""
            result_lower = result.lower() if result else ""
            if result_lower in ["failed", "error"]:
                return "error"
            elif result_lower in ["warn", "warning", "needs review"]:
                return "warning"
            elif result_lower in ["passed", "pass"]:
                return "note"
            else:
                return "none"

        def enrich_sarif(sarif_file, yaml_file):
            # Read SARIF file
            with open(sarif_file, 'r') as f:
                sarif_data = json.load(f)

            # Ensure SARIF structure exists
            if "runs" not in sarif_data:
                sarif_data["runs"] = []

            # Get or create the first run
            if len(sarif_data["runs"]) == 0:
                sarif_data["runs"].append({
                    "tool": {
                        "driver": {
                            "name": "OSPS Security Assessment",
                            "version": "1.0.0"
                        }
                    },
                    "results": []
                })

            run = sarif_data["runs"][0]

            # Initialize results if missing
            if "results" not in run:
                run["results"] = []

            all_results = run["results"]
            existing_rule_ids = set()

            # Ensure all existing results have physicalLocation (required by GitHub Code Scanning)
            for result in all_results:
                if "ruleId" in result:
                    existing_rule_ids.add(result["ruleId"])
                # Add physicalLocation if missing (using README.md as placeholder for repository-level assessments)
                if "locations" not in result or len(result["locations"]) == 0:
                    result["locations"] = [{
                        "physicalLocation": {
                            "artifactLocation": {
                                "uri": "README.md"
                            }
                        }
                    }]
                else:
                    for location in result["locations"]:
                        if "physicalLocation" not in location:
                            location["physicalLocation"] = {
                                "artifactLocation": {
                                    "uri": "README.md"
                                }
                            }

            # Read YAML to find all assessment results
            if yaml_file and os.path.exists(yaml_file):
                try:
                    with open(yaml_file, 'r') as f:
                        yaml_data = yaml.safe_load(f)
                except Exception as e:
                    print(f"⚠️  Error reading YAML: {e}", file=sys.stderr)
                    yaml_data = None

                if yaml_data and "evaluation_suites" in yaml_data:
                    for suite in yaml_data["evaluation_suites"]:
                        if "control_evaluations" in suite:
                            for control in suite["control_evaluations"]:
                                control_id = control.get("control_id", "")
                                if "assessments" in control:
                                    for assessment in control["assessments"]:
                                        req_id = assessment.get("requirement_id", "")
                                        result = assessment.get("result", "")
                                        message = assessment.get("message", "")

                                        if req_id and result and result != "Not Run":
                                            rule_id = f"{control_id}/{req_id}"

                                            # Only add result if not already present
                                            if rule_id not in existing_rule_ids:
                                                level = map_result_to_sarif_level(result)

                                                # Create SARIF result entry with physicalLocation (required by GitHub Code Scanning)
                                                # Include all results (including passed) so GitHub can auto-close previous failures
                                                sarif_result = {
                                                    "ruleId": rule_id,
                                                    "level": level,
                                                    "message": {
                                                        "text": message if message else f"{req_id}: {result}"
                                                    },
                                                    "locations": [{
                                                        "physicalLocation": {
                                                            "artifactLocation": {
                                                                "uri": "README.md"
                                                            }
                                                        },
                                                        "logicalLocations": [{
                                                            "fullyQualifiedName": rule_id
                                                        }]
                                                    }]
                                                }
                                                all_results.append(sarif_result)
                                                existing_rule_ids.add(rule_id)

            # Ensure tool driver name is set
            if "tool" in run and "driver" in run["tool"]:
                if not run["tool"]["driver"].get("name"):
                    run["tool"]["driver"]["name"] = "OSPS Security Assessment"
                # Remove rules array if it exists
                if "rules" in run["tool"]["driver"]:
                    del run["tool"]["driver"]["rules"]

            # Update SARIF with all results
            run["results"] = all_results

            # Write updated SARIF
            with open(sarif_file, 'w') as f:
                json.dump(sarif_data, f, indent=2)

            return len(all_results)

        if __name__ == "__main__":
            sarif_file = sys.argv[1]
            yaml_file = sys.argv[2] if len(sys.argv) > 2 else None
            result_count = enrich_sarif(sarif_file, yaml_file)
            print(f"✅ Enriched SARIF with {result_count} total result(s)")
        PYTHON_SCRIPT

        # Install PyYAML if needed and run the enrichment script
        if command -v python3 >/dev/null 2>&1; then
          python3 -m pip install --quiet PyYAML 2>/dev/null || true
          python3 /tmp/enrich_sarif.py "$SARIF_FILE" "$YAML_FILE" || echo "⚠️  Failed to enrich SARIF file"
        elif command -v python >/dev/null 2>&1; then
          python -m pip install --quiet PyYAML 2>/dev/null || true
          python /tmp/enrich_sarif.py "$SARIF_FILE" "$YAML_FILE" || echo "⚠️  Failed to enrich SARIF file"
        else
          echo "⚠️  Python not found, skipping SARIF enrichment"
        fi

    - name: Prepare SARIF file for upload
      shell: bash
      id: sarif
      if: inputs.upload-sarif == 'true'
      continue-on-error: true
      run: |
        SARIF_FILE=$(find evaluation_results -name "*.sarif" -type f 2>/dev/null | head -1)
        if [ -n "$SARIF_FILE" ] && [ -f "$SARIF_FILE" ]; then
          # Validate that the SARIF file contains at least one result
          # GitHub Code Scanning requires at least one result in runs[].results array
          RESULT_COUNT=$(jq '[.runs[]?.results[]?] | length' "$SARIF_FILE" 2>/dev/null || echo "0")
          if [ "$RESULT_COUNT" -gt 0 ]; then
            echo "✅ SARIF file contains $RESULT_COUNT result(s)"
            echo "sarif_file=$SARIF_FILE" >> $GITHUB_OUTPUT
            echo "has_results=true" >> $GITHUB_OUTPUT
          else
            echo "⚠️  SARIF file exists but contains no results. GitHub Code Scanning requires at least one result."
            echo "sarif_file=" >> $GITHUB_OUTPUT
            echo "has_results=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "⚠️  No SARIF file found in evaluation_results directory"
          echo "sarif_file=" >> $GITHUB_OUTPUT
          echo "has_results=false" >> $GITHUB_OUTPUT
        fi

    - name: Upload SARIF to GitHub Security tab
      if: inputs.upload-sarif == 'true' && steps.sarif.outputs.sarif_file != '' && steps.sarif.outputs.has_results == 'true'
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: ${{ steps.sarif.outputs.sarif_file }}
        wait-for-processing: true
      continue-on-error: true
